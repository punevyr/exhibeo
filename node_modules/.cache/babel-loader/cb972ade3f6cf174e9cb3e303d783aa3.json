{"ast":null,"code":"import _toConsumableArray from \"/Users/charlie/code/ex/exhiibeo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/charlie/code/ex/exhiibeo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/charlie/code/ex/exhiibeo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/charlie/code/ex/exhiibeo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { isCreateEvent, isJoinEvent, isMessageEvent } from '../utils/events';\nimport { MatrixMessage } from './MatrixMessage';\nexport var MatrixRoomStatus;\n\n(function (MatrixRoomStatus) {\n  MatrixRoomStatus[MatrixRoomStatus[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  MatrixRoomStatus[MatrixRoomStatus[\"JOINED\"] = 1] = \"JOINED\";\n  MatrixRoomStatus[MatrixRoomStatus[\"INVITED\"] = 2] = \"INVITED\";\n  MatrixRoomStatus[MatrixRoomStatus[\"LEFT\"] = 3] = \"LEFT\";\n})(MatrixRoomStatus || (MatrixRoomStatus = {}));\n\nexport var MatrixRoom = /*#__PURE__*/function () {\n  function MatrixRoom(id) {\n    var status = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MatrixRoomStatus.UNKNOWN;\n    var members = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var messages = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n    _classCallCheck(this, MatrixRoom);\n\n    this.id = id;\n    this.status = status;\n    this.members = members;\n    this.messages = messages;\n  }\n  /**\n   * Reconstruct rooms from a sync response\n   *\n   * @param roomSync\n   */\n\n\n  _createClass(MatrixRoom, null, [{\n    key: \"fromSync\",\n    value: function fromSync(roomSync) {\n      function create(rooms, creator) {\n        return Object.entries(rooms).map(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              id = _ref2[0],\n              room = _ref2[1];\n\n          return creator(id, room);\n        });\n      }\n\n      return [].concat(_toConsumableArray(create(roomSync.join, MatrixRoom.fromJoined)), _toConsumableArray(create(roomSync.invite, MatrixRoom.fromInvited)), _toConsumableArray(create(roomSync.leave, MatrixRoom.fromLeft)));\n    }\n    /**\n     * Reconstruct a room from an ID or object\n     *\n     * @param roomOrId\n     * @param status\n     */\n\n  }, {\n    key: \"from\",\n    value: function from(roomOrId, status) {\n      return typeof roomOrId === 'string' ? new MatrixRoom(roomOrId, status || MatrixRoomStatus.UNKNOWN) : status !== undefined ? new MatrixRoom(roomOrId.id, status, roomOrId.members, roomOrId.messages) : roomOrId;\n    }\n    /**\n     * Merge new and old state and remove duplicates\n     *\n     * @param newState\n     * @param previousState\n     */\n\n  }, {\n    key: \"merge\",\n    value: function merge(newState, previousState) {\n      if (!previousState || previousState.id !== newState.id) {\n        return MatrixRoom.from(newState);\n      }\n\n      return new MatrixRoom(newState.id, newState.status, [].concat(_toConsumableArray(previousState.members), _toConsumableArray(newState.members)).filter(function (member, index, array) {\n        return array.indexOf(member) === index;\n      }), [].concat(_toConsumableArray(previousState.messages), _toConsumableArray(newState.messages)));\n    }\n    /**\n     * Create a room from a join\n     *\n     * @param id\n     * @param joined\n     */\n\n  }, {\n    key: \"fromJoined\",\n    value: function fromJoined(id, joined) {\n      var events = [].concat(_toConsumableArray(joined.state.events), _toConsumableArray(joined.timeline.events));\n      var members = MatrixRoom.getMembersFromEvents(events);\n      var messages = MatrixRoom.getMessagesFromEvents(events);\n      return new MatrixRoom(id, MatrixRoomStatus.JOINED, members, messages);\n    }\n    /**\n     * Create a room from an invite\n     *\n     * @param id\n     * @param invited\n     */\n\n  }, {\n    key: \"fromInvited\",\n    value: function fromInvited(id, invited) {\n      var members = MatrixRoom.getMembersFromEvents(invited.invite_state.events);\n      return new MatrixRoom(id, MatrixRoomStatus.INVITED, members);\n    }\n    /**\n     * Create a room from a leave\n     *\n     * @param id\n     * @param left\n     */\n\n  }, {\n    key: \"fromLeft\",\n    value: function fromLeft(id, left) {\n      var events = [].concat(_toConsumableArray(left.state.events), _toConsumableArray(left.timeline.events));\n      var members = MatrixRoom.getMembersFromEvents(events);\n      var messages = MatrixRoom.getMessagesFromEvents(events);\n      return new MatrixRoom(id, MatrixRoomStatus.LEFT, members, messages);\n    }\n    /**\n     * Extract members from an event\n     *\n     * @param events\n     */\n\n  }, {\n    key: \"getMembersFromEvents\",\n    value: function getMembersFromEvents(events) {\n      return MatrixRoom.getUniqueEvents(events.filter(function (event) {\n        return isCreateEvent(event) || isJoinEvent(event);\n      })).map(function (event) {\n        return event.sender;\n      }).filter(function (member, index, array) {\n        return array.indexOf(member) === index;\n      });\n    }\n    /**\n     * Extract messages from an event\n     *\n     * @param events\n     */\n\n  }, {\n    key: \"getMessagesFromEvents\",\n    value: function getMessagesFromEvents(events) {\n      return MatrixRoom.getUniqueEvents(events.filter(isMessageEvent)).map(function (event) {\n        return MatrixMessage.from(event);\n      }).filter(Boolean);\n    }\n    /**\n     * Get unique events and remove duplicates\n     *\n     * @param events\n     */\n\n  }, {\n    key: \"getUniqueEvents\",\n    value: function getUniqueEvents(events) {\n      var eventIds = {};\n      var uniqueEvents = [];\n      events.forEach(function (event, index) {\n        var eventId = event.event_id;\n\n        if (eventId === undefined || !(eventId in eventIds)) {\n          if (eventId !== undefined) {\n            eventIds[eventId] = index;\n          }\n\n          uniqueEvents.push(event);\n        }\n      });\n      return uniqueEvents;\n    }\n  }]);\n\n  return MatrixRoom;\n}();","map":{"version":3,"sources":["../../../../src/matrix-client/models/MatrixRoom.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isCreateEvent, isJoinEvent, isMessageEvent } from '../utils/events';\nimport { MatrixMessage } from './MatrixMessage';\nexport var MatrixRoomStatus;\n(function (MatrixRoomStatus) {\n    MatrixRoomStatus[MatrixRoomStatus[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    MatrixRoomStatus[MatrixRoomStatus[\"JOINED\"] = 1] = \"JOINED\";\n    MatrixRoomStatus[MatrixRoomStatus[\"INVITED\"] = 2] = \"INVITED\";\n    MatrixRoomStatus[MatrixRoomStatus[\"LEFT\"] = 3] = \"LEFT\";\n})(MatrixRoomStatus || (MatrixRoomStatus = {}));\nexport class MatrixRoom {\n    constructor(id, status = MatrixRoomStatus.UNKNOWN, members = [], messages = []) {\n        this.id = id;\n        this.status = status;\n        this.members = members;\n        this.messages = messages;\n    }\n    /**\n     * Reconstruct rooms from a sync response\n     *\n     * @param roomSync\n     */\n    static fromSync(roomSync) {\n        function create(rooms, creator) {\n            return Object.entries(rooms).map(([id, room]) => creator(id, room));\n        }\n        return [\n            ...create(roomSync.join, MatrixRoom.fromJoined),\n            ...create(roomSync.invite, MatrixRoom.fromInvited),\n            ...create(roomSync.leave, MatrixRoom.fromLeft)\n        ];\n    }\n    /**\n     * Reconstruct a room from an ID or object\n     *\n     * @param roomOrId\n     * @param status\n     */\n    static from(roomOrId, status) {\n        return typeof roomOrId === 'string'\n            ? new MatrixRoom(roomOrId, status || MatrixRoomStatus.UNKNOWN)\n            : status !== undefined\n                ? new MatrixRoom(roomOrId.id, status, roomOrId.members, roomOrId.messages)\n                : roomOrId;\n    }\n    /**\n     * Merge new and old state and remove duplicates\n     *\n     * @param newState\n     * @param previousState\n     */\n    static merge(newState, previousState) {\n        if (!previousState || previousState.id !== newState.id) {\n            return MatrixRoom.from(newState);\n        }\n        return new MatrixRoom(newState.id, newState.status, [...previousState.members, ...newState.members].filter((member, index, array) => array.indexOf(member) === index), [...previousState.messages, ...newState.messages]);\n    }\n    /**\n     * Create a room from a join\n     *\n     * @param id\n     * @param joined\n     */\n    static fromJoined(id, joined) {\n        const events = [...joined.state.events, ...joined.timeline.events];\n        const members = MatrixRoom.getMembersFromEvents(events);\n        const messages = MatrixRoom.getMessagesFromEvents(events);\n        return new MatrixRoom(id, MatrixRoomStatus.JOINED, members, messages);\n    }\n    /**\n     * Create a room from an invite\n     *\n     * @param id\n     * @param invited\n     */\n    static fromInvited(id, invited) {\n        const members = MatrixRoom.getMembersFromEvents(invited.invite_state.events);\n        return new MatrixRoom(id, MatrixRoomStatus.INVITED, members);\n    }\n    /**\n     * Create a room from a leave\n     *\n     * @param id\n     * @param left\n     */\n    static fromLeft(id, left) {\n        const events = [...left.state.events, ...left.timeline.events];\n        const members = MatrixRoom.getMembersFromEvents(events);\n        const messages = MatrixRoom.getMessagesFromEvents(events);\n        return new MatrixRoom(id, MatrixRoomStatus.LEFT, members, messages);\n    }\n    /**\n     * Extract members from an event\n     *\n     * @param events\n     */\n    static getMembersFromEvents(events) {\n        return MatrixRoom.getUniqueEvents(events.filter((event) => isCreateEvent(event) || isJoinEvent(event)))\n            .map((event) => event.sender)\n            .filter((member, index, array) => array.indexOf(member) === index);\n    }\n    /**\n     * Extract messages from an event\n     *\n     * @param events\n     */\n    static getMessagesFromEvents(events) {\n        return MatrixRoom.getUniqueEvents(events.filter(isMessageEvent))\n            .map((event) => MatrixMessage.from(event))\n            .filter(Boolean);\n    }\n    /**\n     * Get unique events and remove duplicates\n     *\n     * @param events\n     */\n    static getUniqueEvents(events) {\n        const eventIds = {};\n        const uniqueEvents = [];\n        events.forEach((event, index) => {\n            const eventId = event.event_id;\n            if (eventId === undefined || !(eventId in eventIds)) {\n                if (eventId !== undefined) {\n                    eventIds[eventId] = index;\n                }\n                uniqueEvents.push(event);\n            }\n        });\n        return uniqueEvents;\n    }\n}\n//# sourceMappingURL=MatrixRoom.js.map"]},"metadata":{},"sourceType":"module"}