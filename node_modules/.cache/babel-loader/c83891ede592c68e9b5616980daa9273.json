{"ast":null,"code":"import _regeneratorRuntime from \"/Users/charlie/code/ex/exhiibeo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/charlie/code/ex/exhiibeo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/charlie/code/ex/exhiibeo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/**\n * A service to help with matrix event management\n */\n\n\nexport var MatrixEventService = /*#__PURE__*/function () {\n  function MatrixEventService(httpClient) {\n    _classCallCheck(this, MatrixEventService);\n\n    this.httpClient = httpClient;\n    this.cachedPromises = new Map();\n  }\n  /**\n   * Get the latest state from the matrix node\n   *\n   * @param accessToken\n   * @param options\n   */\n\n\n  _createClass(MatrixEventService, [{\n    key: \"sync\",\n    value: function sync(accessToken, options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this.withCache('sync', function () {\n                  return _this.httpClient.get('/sync', {\n                    timeout: options ? options.pollingTimeout : undefined,\n                    since: options ? options.syncToken : undefined\n                  }, {\n                    accessToken: accessToken\n                  });\n                }));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Send a message to a room\n     *\n     * @param accessToken\n     * @param room\n     * @param content\n     * @param txnId\n     */\n\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(accessToken, roomId, content, txnId) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  return _this2.scheduleEvent({\n                    accessToken: accessToken,\n                    roomId: roomId,\n                    type: 'm.room.message',\n                    content: content,\n                    txnId: txnId,\n                    onSuccess: resolve,\n                    onError: reject\n                  });\n                }));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n    }\n    /**\n     * Schedules an event to be sent to the node\n     *\n     * @param event\n     */\n\n  }, {\n    key: \"scheduleEvent\",\n    value: function scheduleEvent(event) {\n      // TODO: actual scheduling\n      this.sendEvent(event);\n    }\n    /**\n     * Send an event to the matrix node\n     *\n     * @param scheduledEvent\n     */\n\n  }, {\n    key: \"sendEvent\",\n    value: function sendEvent(scheduledEvent) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var roomId, type, txnId, content, accessToken, response;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                roomId = scheduledEvent.roomId, type = scheduledEvent.type, txnId = scheduledEvent.txnId, content = scheduledEvent.content, accessToken = scheduledEvent.accessToken;\n                _context3.prev = 1;\n                _context3.next = 4;\n                return this.httpClient.put(\"/rooms/\".concat(encodeURIComponent(roomId), \"/send/\").concat(type, \"/\").concat(encodeURIComponent(txnId)), content, {\n                  accessToken: accessToken\n                });\n\n              case 4:\n                response = _context3.sent;\n                scheduledEvent.onSuccess(response);\n                _context3.next = 11;\n                break;\n\n              case 8:\n                _context3.prev = 8;\n                _context3.t0 = _context3[\"catch\"](1);\n                scheduledEvent.onError(_context3.t0);\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[1, 8]]);\n      }));\n    }\n    /**\n     * Check the cache when interacting with the Matrix node, if there is an already ongoing call for the specified key, return its promise instead of duplicating the call.\n     *\n     * @param key\n     * @param promiseProvider\n     */\n\n  }, {\n    key: \"withCache\",\n    value: function withCache(key, promiseProvider) {\n      var _this3 = this;\n\n      var promise = this.cachedPromises.get(key);\n\n      if (!promise) {\n        promise = promiseProvider().finally(function () {\n          _this3.cachedPromises.delete(key);\n        });\n        this.cachedPromises.set(key, promise);\n      }\n\n      return promise;\n    }\n  }]);\n\n  return MatrixEventService;\n}();","map":{"version":3,"sources":["../../../../src/matrix-client/services/MatrixEventService.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;;AAEG;;;AACH,WAAa,kBAAb;AAGE,8BAA6B,UAA7B,EAAyD;AAAA;;AAA5B,SAAA,UAAA,GAAA,UAAA;AAFZ,SAAA,cAAA,GAA+C,IAAI,GAAJ,EAA/C;AAE4C;AAE7D;;;;;AAKG;;;AAVL;AAAA;AAAA,WAWe,cAAK,WAAL,EAA0B,OAA1B,EAAqD;;;;;;;;iDACzD,KAAK,SAAL,CAAe,MAAf,EAAuB;AAAA,yBAC5B,KAAI,CAAC,UAAL,CAAgB,GAAhB,CACE,OADF,EAEE;AACE,oBAAA,OAAO,EAAE,OAAO,GAAG,OAAO,CAAC,cAAX,GAA4B,SAD9C;AAEE,oBAAA,KAAK,EAAE,OAAO,GAAG,OAAO,CAAC,SAAX,GAAuB;AAFvC,mBAFF,EAME;AAAE,oBAAA,WAAW,EAAX;AAAF,mBANF,CAD4B;AAAA,iBAAvB,C;;;;;;;;;AAUR;AAED;;;;;;;AAOG;;AA/BL;AAAA;AAAA,WAgCe,qBACX,WADW,EAEX,MAFW,EAGX,OAHW,EAIX,KAJW,EAIE;;;;;;;;kDAEN,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV;AAAA,yBACjB,MAAI,CAAC,aAAL,CAAmB;AACjB,oBAAA,WAAW,EAAX,WADiB;AAEjB,oBAAA,MAAM,EAAN,MAFiB;AAGjB,oBAAA,IAAI,EAAE,gBAHW;AAIjB,oBAAA,OAAO,EAAP,OAJiB;AAKjB,oBAAA,KAAK,EAAL,KALiB;AAMjB,oBAAA,SAAS,EAAE,OANM;AAOjB,oBAAA,OAAO,EAAE;AAPQ,mBAAnB,CADiB;AAAA,iBAAZ,C;;;;;;;;;AAWR;AAED;;;;AAIG;;AAvDL;AAAA;AAAA,WAwDS,uBAAc,KAAd,EAA8C;AACnD;AACA,WAAK,SAAL,CAAe,KAAf;AACD;AAED;;;;AAIG;;AAjEL;AAAA;AAAA,WAkEe,mBAAU,cAAV,EAAmD;;;;;;;AACtD,gBAAA,M,GAA8C,c,CAA9C,M,EAAQ,I,GAAsC,c,CAAtC,I,EAAM,K,GAAgC,c,CAAhC,K,EAAO,O,GAAyB,c,CAAzB,O,EAAS,W,GAAgB,c,CAAhB,W;;;AAGnB,uBAAM,KAAK,UAAL,CAAgB,GAAhB,kBACX,kBAAkB,CAAC,MAAD,CADP,mBACwB,IADxB,cACgC,kBAAkB,CAAC,KAAD,CADlD,GAErB,OAFqB,EAGrB;AAAE,kBAAA,WAAW,EAAX;AAAF,iBAHqB,CAAN;;;AAAX,gBAAA,Q;AAKN,gBAAA,cAAc,CAAC,SAAf,CAAyB,QAAzB;;;;;;;AAEA,gBAAA,cAAc,CAAC,OAAf;;;;;;;;;AAEH;AAED;;;;;AAKG;;AAtFL;AAAA;AAAA,WAuFU,mBAAa,GAAb,EAA6B,eAA7B,EAA8D;AAAA;;AACpE,UAAI,OAAO,GAAG,KAAK,cAAL,CAAoB,GAApB,CAAwB,GAAxB,CAAd;;AAEA,UAAI,CAAC,OAAL,EAAc;AACZ,QAAA,OAAO,GAAG,eAAe,GAAG,OAAlB,CAA0B,YAAK;AACvC,UAAA,MAAI,CAAC,cAAL,CAAoB,MAApB,CAA2B,GAA3B;AACD,SAFS,CAAV;AAGA,aAAK,cAAL,CAAoB,GAApB,CAAwB,GAAxB,EAA6B,OAA7B;AACD;;AAED,aAAO,OAAP;AACD;AAlGH;;AAAA;AAAA","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n * A service to help with matrix event management\n */\nexport class MatrixEventService {\n    constructor(httpClient) {\n        this.httpClient = httpClient;\n        this.cachedPromises = new Map();\n    }\n    /**\n     * Get the latest state from the matrix node\n     *\n     * @param accessToken\n     * @param options\n     */\n    sync(accessToken, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.withCache('sync', () => this.httpClient.get('/sync', {\n                timeout: options ? options.pollingTimeout : undefined,\n                since: options ? options.syncToken : undefined\n            }, { accessToken }));\n        });\n    }\n    /**\n     * Send a message to a room\n     *\n     * @param accessToken\n     * @param room\n     * @param content\n     * @param txnId\n     */\n    sendMessage(accessToken, roomId, content, txnId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => this.scheduleEvent({\n                accessToken,\n                roomId,\n                type: 'm.room.message',\n                content,\n                txnId,\n                onSuccess: resolve,\n                onError: reject\n            }));\n        });\n    }\n    /**\n     * Schedules an event to be sent to the node\n     *\n     * @param event\n     */\n    scheduleEvent(event) {\n        // TODO: actual scheduling\n        this.sendEvent(event);\n    }\n    /**\n     * Send an event to the matrix node\n     *\n     * @param scheduledEvent\n     */\n    sendEvent(scheduledEvent) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { roomId, type, txnId, content, accessToken } = scheduledEvent;\n            try {\n                const response = yield this.httpClient.put(`/rooms/${encodeURIComponent(roomId)}/send/${type}/${encodeURIComponent(txnId)}`, content, { accessToken });\n                scheduledEvent.onSuccess(response);\n            }\n            catch (error) {\n                scheduledEvent.onError(error);\n            }\n        });\n    }\n    /**\n     * Check the cache when interacting with the Matrix node, if there is an already ongoing call for the specified key, return its promise instead of duplicating the call.\n     *\n     * @param key\n     * @param promiseProvider\n     */\n    withCache(key, promiseProvider) {\n        let promise = this.cachedPromises.get(key);\n        if (!promise) {\n            promise = promiseProvider().finally(() => {\n                this.cachedPromises.delete(key);\n            });\n            this.cachedPromises.set(key, promise);\n        }\n        return promise;\n    }\n}\n//# sourceMappingURL=MatrixEventService.js.map"]},"metadata":{},"sourceType":"module"}