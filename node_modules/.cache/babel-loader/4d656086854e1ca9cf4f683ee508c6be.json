{"ast":null,"code":"import _slicedToArray from \"/Users/charlie/code/ex/exhiibeo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"/Users/charlie/code/ex/exhiibeo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/charlie/code/ex/exhiibeo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/charlie/code/ex/exhiibeo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/charlie/code/ex/exhiibeo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/charlie/code/ex/exhiibeo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/charlie/code/ex/exhiibeo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { EventEmitter } from 'events';\nimport { keys } from '../utils/utils';\nimport { MatrixRoomStatus } from './models/MatrixRoom';\nimport { MatrixClientEventType } from './models/MatrixClientEvent';\nexport var MatrixClientEventEmitter = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(MatrixClientEventEmitter, _EventEmitter);\n\n  var _super = _createSuper(MatrixClientEventEmitter);\n\n  function MatrixClientEventEmitter() {\n    var _this;\n\n    _classCallCheck(this, MatrixClientEventEmitter);\n\n    _this = _super.apply(this, arguments);\n    _this.eventEmitProviders = new Map([[MatrixClientEventType.INVITE, function () {\n      return [_this.isInvite, _this.emitInvite.bind(_assertThisInitialized(_this))];\n    }], [MatrixClientEventType.MESSAGE, function () {\n      return [_this.isMessage, _this.emitMessage.bind(_assertThisInitialized(_this))];\n    }]]);\n    return _this;\n  }\n  /**\n   * This method is called every time the state is changed\n   *\n   * @param _oldState\n   * @param _newState\n   * @param stateChange\n   */\n\n\n  _createClass(MatrixClientEventEmitter, [{\n    key: \"onStateChanged\",\n    value: function onStateChanged(_oldState, _newState, stateChange) {\n      var _iterator = _createForOfIteratorHelper(keys(MatrixClientEventType)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var event = _step.value;\n          this.emitIfEvent(MatrixClientEventType[event], stateChange);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Emit the message if we have listeners registered for that type\n     *\n     * @param eventType\n     * @param object\n     */\n\n  }, {\n    key: \"emitIfEvent\",\n    value: function emitIfEvent(eventType, object) {\n      var provider = this.eventEmitProviders.get(eventType);\n\n      if (provider) {\n        var _provider = provider(),\n            _provider2 = _slicedToArray(_provider, 2),\n            predicate = _provider2[0],\n            emitter = _provider2[1];\n\n        if (predicate(object)) {\n          emitter(eventType, object);\n        }\n      }\n    }\n    /**\n     * Emit a client event\n     *\n     * @param eventType\n     * @param content\n     */\n\n  }, {\n    key: \"emitClientEvent\",\n    value: function emitClientEvent(eventType, content, timestamp) {\n      this.emit(eventType, {\n        type: eventType,\n        content: content,\n        timestamp: timestamp\n      });\n    }\n    /**\n     * Check if event is an invite\n     *\n     * @param stateChange\n     */\n\n  }, {\n    key: \"isInvite\",\n    value: function isInvite(stateChange) {\n      return stateChange.rooms ? stateChange.rooms.some(function (room) {\n        return room.status === MatrixRoomStatus.INVITED;\n      }) : false;\n    }\n    /**\n     * Emit an invite\n     *\n     * @param eventType\n     * @param stateChange\n     */\n\n  }, {\n    key: \"emitInvite\",\n    value: function emitInvite(eventType, stateChange) {\n      var _this2 = this;\n\n      stateChange.rooms.filter(function (room) {\n        return room.status === MatrixRoomStatus.INVITED;\n      }).map(function (room) {\n        return [room.id, room.members];\n      }).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            id = _ref2[0],\n            members = _ref2[1];\n\n        _this2.emitClientEvent(eventType, {\n          roomId: id,\n          members: members\n        });\n      });\n    }\n    /**\n     * Check if event is a message\n     *\n     * @param stateChange\n     */\n\n  }, {\n    key: \"isMessage\",\n    value: function isMessage(stateChange) {\n      return stateChange.rooms ? stateChange.rooms.some(function (room) {\n        return room.messages.length > 0;\n      }) : false;\n    }\n    /**\n     * Emit an event to all rooms\n     *\n     * @param eventType\n     * @param stateChange\n     */\n\n  }, {\n    key: \"emitMessage\",\n    value: function emitMessage(eventType, stateChange) {\n      var _this3 = this;\n\n      stateChange.rooms.filter(function (room) {\n        return room.messages.length > 0;\n      }).map(function (room) {\n        return room.messages.map(function (message) {\n          return [room.id, message, message.timestamp];\n        });\n      }).reduce(function (flatten, toFlatten) {\n        return flatten.concat(toFlatten);\n      }, []).forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 3),\n            roomId = _ref4[0],\n            message = _ref4[1],\n            timestamp = _ref4[2];\n\n        _this3.emitClientEvent(eventType, {\n          roomId: roomId,\n          message: message\n        }, timestamp);\n      });\n    }\n  }]);\n\n  return MatrixClientEventEmitter;\n}(EventEmitter);","map":{"version":3,"sources":["../../../src/matrix-client/MatrixClientEventEmitter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { EventEmitter } from 'events';\nimport { keys } from '../utils/utils';\nimport { MatrixRoomStatus } from './models/MatrixRoom';\nimport { MatrixClientEventType } from './models/MatrixClientEvent';\nexport class MatrixClientEventEmitter extends EventEmitter {\n    constructor() {\n        super(...arguments);\n        this.eventEmitProviders = new Map([\n            [MatrixClientEventType.INVITE, () => [this.isInvite, this.emitInvite.bind(this)]],\n            [MatrixClientEventType.MESSAGE, () => [this.isMessage, this.emitMessage.bind(this)]]\n        ]);\n    }\n    /**\n     * This method is called every time the state is changed\n     *\n     * @param _oldState\n     * @param _newState\n     * @param stateChange\n     */\n    onStateChanged(_oldState, _newState, stateChange) {\n        for (const event of keys(MatrixClientEventType)) {\n            this.emitIfEvent(MatrixClientEventType[event], stateChange);\n        }\n    }\n    /**\n     * Emit the message if we have listeners registered for that type\n     *\n     * @param eventType\n     * @param object\n     */\n    emitIfEvent(eventType, object) {\n        const provider = this.eventEmitProviders.get(eventType);\n        if (provider) {\n            const [predicate, emitter] = provider();\n            if (predicate(object)) {\n                emitter(eventType, object);\n            }\n        }\n    }\n    /**\n     * Emit a client event\n     *\n     * @param eventType\n     * @param content\n     */\n    emitClientEvent(eventType, content, timestamp) {\n        this.emit(eventType, {\n            type: eventType,\n            content,\n            timestamp\n        });\n    }\n    /**\n     * Check if event is an invite\n     *\n     * @param stateChange\n     */\n    isInvite(stateChange) {\n        return stateChange.rooms\n            ? stateChange.rooms.some((room) => room.status === MatrixRoomStatus.INVITED)\n            : false;\n    }\n    /**\n     * Emit an invite\n     *\n     * @param eventType\n     * @param stateChange\n     */\n    emitInvite(eventType, stateChange) {\n        stateChange.rooms\n            .filter((room) => room.status === MatrixRoomStatus.INVITED)\n            .map((room) => [room.id, room.members])\n            .forEach(([id, members]) => {\n            this.emitClientEvent(eventType, {\n                roomId: id,\n                members: members\n            });\n        });\n    }\n    /**\n     * Check if event is a message\n     *\n     * @param stateChange\n     */\n    isMessage(stateChange) {\n        return stateChange.rooms ? stateChange.rooms.some((room) => room.messages.length > 0) : false;\n    }\n    /**\n     * Emit an event to all rooms\n     *\n     * @param eventType\n     * @param stateChange\n     */\n    emitMessage(eventType, stateChange) {\n        stateChange.rooms\n            .filter((room) => room.messages.length > 0)\n            .map((room) => room.messages.map((message) => [room.id, message, message.timestamp]))\n            .reduce((flatten, toFlatten) => flatten.concat(toFlatten), [])\n            .forEach(([roomId, message, timestamp]) => {\n            this.emitClientEvent(eventType, {\n                roomId,\n                message\n            }, timestamp);\n        });\n    }\n}\n//# sourceMappingURL=MatrixClientEventEmitter.js.map"]},"metadata":{},"sourceType":"module"}